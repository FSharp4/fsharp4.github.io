<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="https://fsharp4.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://fsharp4.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2024-12-30T19:49:59+00:00</updated><id>https://fsharp4.github.io/feed.xml</id><title type="html">blank</title><subtitle>Personal Website &amp; Project Portfolio. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">Project Deep Dive: Matrix Multiplication with Systolic Arrays</title><link href="https://fsharp4.github.io/blog/2024/matmul-systolic-arrays/" rel="alternate" type="text/html" title="Project Deep Dive: Matrix Multiplication with Systolic Arrays"/><published>2024-12-26T15:00:00+00:00</published><updated>2024-12-26T15:00:00+00:00</updated><id>https://fsharp4.github.io/blog/2024/matmul-systolic-arrays</id><content type="html" xml:base="https://fsharp4.github.io/blog/2024/matmul-systolic-arrays/"><![CDATA[<h1 id="setting-the-stage">Setting the Stage</h1> <p>Three students walk into the collaborative study space at <a href="https://today.usc.edu/5-things-you-need-to-know-about-leavey-library/">Leavey Library</a>, packing two months of instruction on MOS transistors, a project description detailing several dozen hours of work, and some (convenient, if perhaps economically ill-advised) starbucks coffees. None of us have prior exposure to the VLSI industry. One of those students is me ☺</p> <p>(This was our first real foray into VLSI design. While I’ve performed schematic/layout tasks as part of my job at Emerson, the skills I developed for analog PCB design largely did not apply to digital MOS design tasks at this scale, outside of some keybind similarities between Cadence Virtuoso and Allegro System Capture. Ergo, all three of us started with fresh slates.)</p> <p>For the first two months of this course, we completed contributory design activities without knowing the project spec (which changes on a semesterly basis). Our prior labs saw us design a set of <a href="https://en.wikipedia.org/wiki/CMOS">Complementary MOS</a> (CMOS) logic gates, out of which we built <a href="https://www.circuitstoday.com/ripple-carry-adder">Ripple-Carry</a> and <a href="https://en.wikipedia.org/wiki/Carry-skip_adder">Carry-Bypass</a> adders using a hierarchy of standard cells. Finally, after our first exam in November the project spec dropped:</p> <h1 id="project-description">Project Description</h1> <p><strong>Our task:</strong> Design a systolic array matrix mulitplier for 4x4 matrices, consisting of 4-bit unsigned integers.</p> <p>A refresher on matrix multiplication (since I always seem to need it too):</p> <ol> <li>Take the <em>i</em>-th row of the first matrix</li> <li>Multiply all elements against their counterparts in the <em>j</em>-th column of the second matrix</li> <li>Sum all the products together. That’s the value of element \(c_{i, j}\)</li> </ol> \[\textbf{AB = C}\] \[\begin{bmatrix} a_{1,1} &amp; a_{1,2} &amp; a_{1,3} &amp; a_{1,4} \\ a_{2,1} &amp; a_{2,2} &amp; a_{2,3} &amp; a_{2,4} \\ a_{3,1} &amp; a_{3,2} &amp; a_{3,3} &amp; a_{3,4} \\ a_{4,1} &amp; a_{4,2} &amp; a_{4,3} &amp; a_{4,4} \end{bmatrix} \begin{bmatrix} b_{1,1} &amp; b_{1,2} &amp; b_{1,3} &amp; b_{1,4} \\ b_{2,1} &amp; b_{2,2} &amp; b_{2,3} &amp; b_{2,4} \\ b_{3,1} &amp; b_{3,2} &amp; b_{3,3} &amp; b_{3,4} \\ b_{4,1} &amp; b_{4,2} &amp; b_{4,3} &amp; b_{4,4} \end{bmatrix} =\begin{bmatrix} c_{1,1} &amp; c_{1,2} &amp; c_{1,3} &amp; c_{1,4} \\ c_{2,1} &amp; c_{2,2} &amp; c_{2,3} &amp; c_{2,4} \\ c_{3,1} &amp; c_{3,2} &amp; c_{3,3} &amp; c_{3,4} \\ c_{4,1} &amp; c_{4,2} &amp; c_{4,3} &amp; c_{4,4} \end{bmatrix}\] <p>where:</p> \[c_{i,j} = \sum_{k=1}^{4} a_{i,k} \cdot b_{k,j}\] <p>(for example:)</p> \[c_{1, 2} = a_{1, 1}b_{1, 2} + a_{1, 2}b_{2, 2} + a_{1, 3}b_{3, 2} + a_{1, 4}b_{4, 2}\] <p>This is a much more involved project than our prior labs, and we haven’t even gotten to the central question of the project:</p> <h2 id="what-are-systolic-arrays-and-how-do-they-work">What are systolic arrays, and how do they work?</h2> <p><a href="https://www.telesens.co/2018/07/30/systolic-architectures/"><strong>Systolic arrays</strong></a> are parallel hardware architectures constructed of arrays of processing elements. Each processing element performs part of a task and stores part of the result. This is useful for matrix multiplication, where there are many separable subtasks (i.e., elements to compute) with many intermediates (i.e., partial sums).</p> <p>Data flows between adjacent processing elements. This:</p> <ul> <li>Keeps wires short (improving interconnect timings, which are otherwise the <a href="http://async.org.uk/noc2006/pdf/Eby-Friedman.pdf">main timing bottleneck</a>)</li> <li>Enables pipelining data between elements (good for matmul!)</li> <li>Organizes I/O so that it only appears at the edges of the array</li> </ul> <p><img src="/assets/img/samm/Systolic%20Array%204x4.drawio.jpg" alt="Systolic Array Matrix Multiplication Figure" width="100%"/></p> <p>The above figure details how data flows through the systolic array for matrix multiplication:</p> <ol> <li>The multiplicand matrix \(\textbf{A}\) streams left-to-right through the rows of processing elements, along the indicated interconnects. (Each row of the matrix goes through the corresponding row of processing elements.)</li> <li>The multiplier matrix \(\textbf{B}\) streams from top to bottom through the columns of processing elements. (Each column of the matrix goes through the corresponding column.)</li> <li>The product matrix is iteratively produced inside the processing element (where the position of the processing element matches the position of the matrix element which is stored). Id est, the element in the fourth row, third column stores \(c_{4, 3}\).</li> </ol> <p>Both input matrices <em>pipeline</em> (visit, and then leave) through the processing elements in the indicated directions.</p> <ul> <li>Each four-bit element of the matrix spends one clock cycle in a processing element before moving to the next.</li> <li>Therefore, a series of four numbers: <ul> <li>Takes four clock cycles to pass through a single processing element, and</li> <li>Takes seven clock cycles to pass through a row or column completely.</li> </ul> </li> </ul> <p>The \(\textbf{A}\) and \(\textbf{B}\) matrix pass through the systolic array <em>simultaneously</em> and in a “diagonal” fashion, so that the necessary elements needed to produce partial sums are present in their correct processing elements at the correct times. When the individual product elements are ready, they are transmitted to the output pins at the top of the array.</p> <p>This isn’t a super intuitive explanation, so instead I’ll link to this GIF:</p> <div style="width:100%;height:0;padding-bottom:89%;position:relative;"> <iframe src="https://giphy.com/embed/8vZUh9LrkN4llUUxaN" width="100%" height="100%" style="position:absolute" frameborder="0" class="giphy-embed" allowfullscreen=""></iframe> </div> <p> <a href="https://giphy.com/gifs/systolic-matrix-multiplication-8vZUh9LrkN4llUUxaN"> via GIPHY </a> </p> <p>The GIF uses a different indexing system than I do, so I’ll limit my analysis to the following observations:</p> <ol> <li>The rows/columns sent through the matrix start their journeys one cycle apart. Row \(i\) of matrix \(\textbf{A}\) starts at cycle \(i\), which is exactly when column \(i\) starts as well.</li> <li>Each processing element at position \((i, j)\) will see the \(i\)-th row of \(\textbf{A}\) and the \(j\)-th column of \(\textbf{B}\).</li> <li>These are the correct numbers to produce \(c_{i, j}\), which is available <em>immediately after</em> the required row/column finishes passing through the processing element (at the top of the next clock cycle). Details for exactly how this happens are discussed later.</li> </ol> <p>This enables a space-efficient, high-frequency, and relatively simple matrix multiplication implementation, which matches well with how the project was setup:</p> <h2 id="goal-optimizing-for-power-area-and-delay-pad">Goal: Optimizing for Power, Area, and Delay (PAD)</h2> <p>This project was setup as a course contest, with PAD minimization being the sole judging criteria. (Also important: the project has to work! This is an important point which will be discussed later.)</p> <ul> <li><strong>Power</strong> is judged by how many microwatts the device consumed while producing a matrix product</li> <li><strong>Area</strong> is judged by how many square microns the device footprint requires. We were additionally told that our device should be as square as possible, as this criterion was tweaked to calculate area as the square of the longest dimension.</li> <li><strong>Delay</strong> is judged by how long the device takes to calculate the product. For simplicity, this criterion is reduced to be a measurement of the clock cycle period.</li> </ul> <blockquote> <p>(PAD is also known as PPA: Power, Performance, and Area.)</p> </blockquote> <p>This project was split into three phases:</p> <ul> <li><strong>Phase 1</strong>: Design of multiply-accumulate hardware (to iteratively acquire the product elements)</li> <li><strong>Phase 2</strong>: Design of the processing element and a vector multiplier (a single column of processing elements)</li> <li><strong>Phase 3</strong>: Systolic Array Design (using the vector multiplier designed earlier)</li> </ul> <p>We chose to largely forgo aggressive design optimizations (such as transistor sizing, non-CMOS logics, and routing variants to minimize parasitics) so that we could balance this project with the collection of other coincident labs, exams, and assignments. This meant we largely stayed within a hierarchical standard-cell design workflow, utilizing CMOS and <a href="https://en.wikipedia.org/wiki/Transmission_gate">Transmission-Gate Logic</a> (TGL).</p> <p>For our course we used GPDK045 with Cadence Virtuoso to implement our designs.</p> <h1 id="phase-1-mac-building-blocks">Phase 1: MAC Building blocks</h1> <p>There are three components required for multiply-accumulate hardware on 4-bit unsigned integers:</p> <ol> <li>A four-bit multiplier (produces 8-bit products)</li> <li>A 10-bit adder, accepting the product as one operand and an intermediate sum as the other</li> <li>A 10-bit register, connected with the adder in a feedback loop</li> </ol> <p>Diagram:</p> <p><img src="/assets/img/samm/MAC.drawio.jpg" alt="MAC" width="100%"/></p> <p>We chose to use an array multiplier and a ripple-carry adder (RCA) because our bit counts were too low to justify implementing more advanced adder/multiplier designs. (Discussions with course TAs and the professor advised us that they would not have been faster.) We used a TGL master-slave D flip flop design for our register.</p> <h2 id="division-of-work-and-the-first-trap-laid">Division of Work (and the first trap laid)</h2> <p>Now, one may think that three team members and three components produces a very obvious work division scheme of one component per member.</p> <p>This may have worked if each member acted as a ‘lead’ for development of that component and pulled in other team members as needed. However, we did not yet have our collaboration routines grooved, and largely chose to implement our respective components individually. This was very bad for scheduling, as the one who claimed responsibility for the multiplier found their design task extremely daunting. (Keep in mind, we had a ripple-carry adder design from the previous labs, and in comparison to a register design, the multiplier design is far more involved.)</p> <p>By the time we learnt our lesson, our multiplier man had spent several days of staring at angry <a href="https://en.wikipedia.org/wiki/Design_rule_checking">Design Rule Check</a> (DRC) screens with hundreds of errors. Not all was doom and gloom, however.</p> <h2 id="epiphany-i-surpassing-hierarchical-standard-cell-design">Epiphany I: Surpassing hierarchical standard cell design</h2> <p>Several improvements were enabled in the slack time resulting from the multiplier effort.</p> <p>The RCA adder was redesigned with smaller logic gates and a placement scheme that vertically stacked pairs of mirrored full adders such that their power/ground rails were abutted.</p> <p>The register underwent a full-custom redesign complete with individual transistor sizing that resulted in a 50ps improvement in propagation delay (from 120 down to 70) and a ~60% reduction in size.</p> <p>The resulting multiplier design was extremely aggressive in its optimization strategies. Our engineer had completed a first pass design that passed DRC, LVS (Layout Versus Schematic), and the functional verification test suite provided to us as part of project spec. His second design aggressively reduced the spacing between transistors and stripped the pads on the cell templates for some standard cell variants, allowing their power/ground rails to overlap seamlessly. Both of these changes invalidated some DRC and LVS rules, but produced an effectively full-custom multiplier design that passed both suites of checks.</p> <p>The resulting register and adder designs align nicely. However, the multiplier design is very long, as we elected to reserve one ‘row’ of cell template per bit of input operand. Placing the output pins at the bottom of the multiplier and rotating the multiplier by \(90^\circ\) ameliorates the issue.</p> <p><img src="/assets/img/samm/MAC%20Layout.jpg" alt="MAC Layout" width="100%"/></p> <p>Remarks:</p> <ul> <li>We had not yet ‘extracted’ the input pins from the multiplier as we were unsure where they would be routed in future phases of the project.</li> <li>The register contains a reset signal to initialize the MAC register contents between multiplications and on power-on.</li> </ul> <h1 id="phase-2-systolic-array-processing-elements">Phase 2: Systolic Array Processing Elements</h1> <p>The processing element consists of a few resistors to provide data storage for the input data lines and a multiplexer to selectively expose the stored product (when it is time). The multiplexer has a control signal which will pass along processing elements in a row and must also be registered.</p> <p><img src="/assets/img/samm/matrix%20multiplication%20processing%20element.jpg" alt="Matrix Multiplication Processing Element" width="100%"/></p> <p>Within the diagram:</p> <ul> <li>The \(\textbf{A}\) input lines start at left, feeding to the multiplier and tracing across the processing element, getting registered, then appearing at the right side.</li> <li>The \(\textbf{B}\) input lines start at top, feeding to the multiplier, then getting registered and appearing on the bottom side.</li> <li>The <code class="language-plaintext highlighter-rouge">sel</code> input lines trace left-to-right, getting registered before getting fed to the multiplexer.</li> <li>The <code class="language-plaintext highlighter-rouge">sum_out</code> output pins at top present data controlled by the <code class="language-plaintext highlighter-rouge">sel_reg</code>-controlled multiplexer. This is either the internal MAC product (if <code class="language-plaintext highlighter-rouge">sel_reg</code> is 0) or a passed-along version of the <code class="language-plaintext highlighter-rouge">sum_out</code> data from a processing element below this one. (There is a set of <code class="language-plaintext highlighter-rouge">sum_in</code> pins present on the bottom side.)</li> </ul> <p>The layout of the design largely matches the diagram. There is a not-insignificant amount of decision-making needed to determine component placement of the three extra registers within the processing element (all of which use the same design as in MAC). However, there is a more pressing question:</p> <h2 id="how-should-we-route-signals-through-the-processing-element">How should we route signals through the processing element?</h2> <p>This question is twofold:</p> <ol> <li>How should the wires cross between components to minimize delay?</li> <li>Where should the wires be routed?</li> </ol> <p>These concerns are made nontrivial by our lack of knowledge about Virtuoso’s built-in automated routing routines (which we were not disallowed from using, but were not instructed on how to use). We therefore had to complete routing largely by hand.</p> <p>We quickly adopted systematic approaches to wiring decisions at this level, because we observed that interconnect delays started to get somewhat unwieldy at the end of phase one within the MAC.</p> <p>One approach that improved our results was a practice of reusing as much of lower-level routing as possible: Virtuoso only seems to recognize net connections at higher levels to lower levels in a hierarchical design by routing them through the pins. This can be bypassed by laying the wire on the same net within the lower level design (using the same metals). Furthermore, if one can identify points along such internal nets that are closest to each other, this was observed to improve interconnect delays, if only minutely. We did not use this strategy to its highest extent but it did inform our routing decisions.</p> <p>We didn’t find strategies for reducing layout routing difficulty. (For the processing element, this was much harder than the RCA and register design tasks, if not as hard as the multiplier.) One thing that did make our lives easier was configuring Virtuoso to show layout pin labels (and labelling our pins manually). However, this still meant we had dozens of connections to make, accessing nets which are largely without labels (since they exist on lower levels of the hierarchy).</p> <p>What I am trying to say with all this writing: routing for the processing element was a hard task. We foresaw this to be even worse with the vector and matrix multipliers. We wanted to make our lives easier, so we did this in response:</p> <h2 id="epiphany-ii-aligned-io-tracks-for-easier-downstream-layout-tasks">Epiphany II: Aligned I/O tracks for easier downstream layout tasks</h2> <p>Our strategy had three prongs:</p> <ol> <li>Input and output pins must be placed such that they are aligned.</li> <li>Horizontal nets and vertical nets must use a dedicated, different metal layer to the maximum extent possible.</li> <li>Multi-bit signals must be laid out such that they use multiple adjacent and tightly-arranged routing channels.</li> </ol> <p>This produced a very intelligible and somewhat-advantaged routing scheme. Multi-bit channels (particularly <code class="language-plaintext highlighter-rouge">sum_out</code>) always fed to internal pins which themselves were aligned (i.e., had the same x or y coordinate). Placing a group of routing tracks centred on this alignment coordinate made it very straightforward to interface with multi-bit signals.</p> <p>Our strategy of dedicated metal layers also meant we were able to keep our processing element design (<em>as well as both multipliers thereafter!</em>) to only four metal layers, which helps reduce interconnect delay.</p> <p>Finally, aligning the I/O pins meant that when we string multiple processing elements together, it is trivial to route their connections. (All one needs to do is place straight, short metal wires to connect the vast majority of signals. The only two that need some work are clock and reset pins, which will be discussed later.)</p> <p>In connection with a decision to place the registers in the open space above and below the MAC RCA/register, the end result is a very square layout:</p> <p><img src="/assets/img/samm/processing_element.jpg" alt="Processing Element Layout 1" width="100%"/></p> <p>The pin-out largely matches the diagram. Details:</p> <ul> <li>Component placement: <ul> <li>The 4-bit registers for \(\textbf{A}\) and \(\textbf{B}\) are placed below and above the MAC adder/register circuitry, respectively. They are arranged such that the individual flip flops are aligned horizontally (instead of vertically) to make efficient use out of the empty space.</li> <li>The 1-bit register for the <code class="language-plaintext highlighter-rouge">sel</code> signal is placed in the lower right corner.</li> </ul> </li> <li>Left side: <ul> <li>The clock pin is placed at the middle of the left side</li> <li>The \(\textbf{A}\) element input pins are placed well below <code class="language-plaintext highlighter-rouge">clk</code></li> <li>The <code class="language-plaintext highlighter-rouge">sel</code> pin is placed at the bottom of the left side, below the \(\textbf{A}\) pins.</li> </ul> </li> <li>Right side: <ul> <li>The registered \(\textbf{A}\) output pins are placed on the right side, aligned with their counterparts on the left.</li> <li>The <code class="language-plaintext highlighter-rouge">sel_reg</code> pin is likewise placed on the right</li> </ul> </li> <li>Top side: <ul> <li>The \(\textbf{B}\) input pins are placed above the adder/register hardware spaced evenly along the top side. There is plenty of space between these pins (which could potentially be reduced in more optimal designs).</li> <li>The <code class="language-plaintext highlighter-rouge">sum_out</code> pins are placed on the top side, tightly clustered towards the right corner. This was done so they can all be routed to/from the multiplexer, which was placed to the right of the MAC.</li> </ul> </li> <li>Bottom side: <ul> <li>The registered \(\textbf{B}\) output pins are placed on the bottom side, aligned with their inputs up top.</li> <li>The <code class="language-plaintext highlighter-rouge">sum_in</code> input pins are placed in a tight cluster on the bottom right corner, aligned with their <code class="language-plaintext highlighter-rouge">sum_out</code> counterparts.</li> <li>The reset pin is placed on the bottom side between two registered \(\textbf{B}\) output pins, directly aligned over the internal reset pins for the \(\textbf{A}\) and $\textbf{B}$$ registers.</li> </ul> </li> </ul> <p>These choices simplify future layouts by making it easier to bridge signals between processing elements and simplifying the paths that propagating signals need to take (straight lines, minimal corners and vias).</p> <h1 id="phase-3-vector-and-matrix-multipliers">Phase 3: Vector and Matrix Multipliers</h1> <p>We leveraged the processing element to construct:</p> <ul> <li>A vector multiplier (by placing 4 processing elements in a column), and</li> <li>A matrix multiplier (by placing 4 vector multipliers in a row).</li> </ul> <p>Vector multiplier layout:</p> <p><img src="/assets/img/samm/vector_layout_multiview.jpg" alt="Vector multiplier layout" width="100%"/></p> <p>Matrix multiplier layout:</p> <p><img src="/assets/img/samm/matrixmultiplier.jpg" alt="Matrix multiplier layout" width="100%"/></p> <p>These multipliers use the internal multiplexers to expose their results. When the internal MAC sum finishes accumulating products:</p> <ol> <li>At that cycle, the processing element receives <code class="language-plaintext highlighter-rouge">sel=0</code>.</li> <li>This signal is registered, and at the next clock cycle appears as <code class="language-plaintext highlighter-rouge">sel_reg=0</code>.</li> <li>When <code class="language-plaintext highlighter-rouge">sel_reg=0</code>, the multiplexer exposes the MAC sum on the <code class="language-plaintext highlighter-rouge">sum_out</code> pins for that column of processing elements.</li> </ol> <p>This produces a “diamond” of results: one cycle after the last inputs of the first column and first row are sent, the MAC sum of the top left processing element is displayed on <code class="language-plaintext highlighter-rouge">sum_out</code>. In next cycle, the processing elements to the bottom and right will display their MAC sums on their respective <code class="language-plaintext highlighter-rouge">sum_out</code> lines. This continues until, six clock cycles after the first sum is produced, the last MAC sum (from the bottom right processing element) is displayed on the <code class="language-plaintext highlighter-rouge">sum_out</code> pins of the last column.</p> <p>Now that we’ve constructed a prototype for our final project, there remains the need to test it. Our course’s initial workflow of defining stimuli within <a href="https://community.cadence.com/cadence_blogs_8/b/cic/posts/virtuosity-creating-and-previewing-stimuli">Virtuoso’s built-in stimuli editor</a> becomes too unwieldy for designs of this scale. (We need four stimuli signals per four-bit signal, and now we have eight of those!) Luckily, Virtuoso supports specifying multiple stimuli signals via <a href="https://eda.engineering.wustl.edu/wiki/index.php/Tutorials:Cadence:AdvancedTopics">digital vector files</a>, but the process for writing them is still tedious. What if we want to use<br/> multiple test cases? Writing multiple 4x4 matrices in binary notation by hand is not how my team wanted to spend our afternoons. I made a quick solution to resolve this bind:</p> <h2 id="epiphany-iii-automating-vector-files-for-functional-verification">Epiphany III: Automating Vector Files for Functional Verification</h2> <p>Our course’s fourth lab (assigned during the project) introduced python as a means of automation for things like data parsing, generation, analysis, etc. I saw an easy opportunity to apply this to writing vector files containing our multi-bit signals.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">_hex</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
	<span class="k">return</span> <span class="nf">hex</span><span class="p">(</span><span class="n">i</span><span class="p">)[</span><span class="mi">2</span><span class="p">].</span><span class="nf">upper</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">make_case</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
	<span class="sh">"""</span><span class="s">Makes a systolic array case

	Args:
    	a (List[List[int]]): A 4x4 multiplicand matrix (represented as a list of lists)
    	b (List[List[int]]): A 4x4 multiplier matrix (represented as a list of lists)

	Returns:
    	List[List[int]]: A systolic array case (represented as a list of lists) that performs matmul(a, b)
	</span><span class="sh">"""</span>
	<span class="k">return</span> <span class="sa">f</span><span class="sh">"""</span><span class="s">
;autogenerated systolic array case for matmul(a, b)
;------------------------------------------------------------------------------
;</span><span class="si">{</span><span class="nf">_hex</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span><span class="si">}</span><span class="s"> </span><span class="si">{</span><span class="nf">_hex</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span><span class="si">}</span><span class="s"> </span><span class="si">{</span><span class="nf">_hex</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span><span class="si">}</span><span class="s"> </span><span class="si">{</span><span class="nf">_hex</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">3</span><span class="p">])</span><span class="si">}</span><span class="s"> | </span><span class="si">{</span><span class="nf">_hex</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span><span class="si">}</span><span class="s"> </span><span class="si">{</span><span class="nf">_hex</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span><span class="si">}</span><span class="s"> </span><span class="si">{</span><span class="nf">_hex</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span><span class="si">}</span><span class="s"> </span><span class="si">{</span><span class="nf">_hex</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">3</span><span class="p">])</span><span class="si">}</span><span class="s">
;</span><span class="si">{</span><span class="nf">_hex</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span><span class="si">}</span><span class="s"> </span><span class="si">{</span><span class="nf">_hex</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span><span class="si">}</span><span class="s"> </span><span class="si">{</span><span class="nf">_hex</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span><span class="si">}</span><span class="s"> </span><span class="si">{</span><span class="nf">_hex</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">3</span><span class="p">])</span><span class="si">}</span><span class="s"> | </span><span class="si">{</span><span class="nf">_hex</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span><span class="si">}</span><span class="s"> </span><span class="si">{</span><span class="nf">_hex</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span><span class="si">}</span><span class="s"> </span><span class="si">{</span><span class="nf">_hex</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span><span class="si">}</span><span class="s"> </span><span class="si">{</span><span class="nf">_hex</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">3</span><span class="p">])</span><span class="si">}</span><span class="s">
;</span><span class="si">{</span><span class="nf">_hex</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span><span class="si">}</span><span class="s"> </span><span class="si">{</span><span class="nf">_hex</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span><span class="si">}</span><span class="s"> </span><span class="si">{</span><span class="nf">_hex</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span><span class="si">}</span><span class="s"> </span><span class="si">{</span><span class="nf">_hex</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">3</span><span class="p">])</span><span class="si">}</span><span class="s"> | </span><span class="si">{</span><span class="nf">_hex</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span><span class="si">}</span><span class="s"> </span><span class="si">{</span><span class="nf">_hex</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span><span class="si">}</span><span class="s"> </span><span class="si">{</span><span class="nf">_hex</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span><span class="si">}</span><span class="s"> </span><span class="si">{</span><span class="nf">_hex</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">3</span><span class="p">])</span><span class="si">}</span><span class="s">
;</span><span class="si">{</span><span class="nf">_hex</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span><span class="si">}</span><span class="s"> </span><span class="si">{</span><span class="nf">_hex</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span><span class="si">}</span><span class="s"> </span><span class="si">{</span><span class="nf">_hex</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span><span class="si">}</span><span class="s"> </span><span class="si">{</span><span class="nf">_hex</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">3</span><span class="p">])</span><span class="si">}</span><span class="s"> | </span><span class="si">{</span><span class="nf">_hex</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span><span class="si">}</span><span class="s"> </span><span class="si">{</span><span class="nf">_hex</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span><span class="si">}</span><span class="s"> </span><span class="si">{</span><span class="nf">_hex</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span><span class="si">}</span><span class="s"> </span><span class="si">{</span><span class="nf">_hex</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">3</span><span class="p">])</span><span class="si">}</span><span class="s">
;------------------------------------------------------------------------------
;ape4&lt;[3:0]&gt;,ape3&lt;[3:0]&gt;,ape2&lt;[3:0]&gt;,ape1&lt;[3:0]&gt;,bmvm1&lt;[3:0]&gt;,bmvm2&lt;[3:0]&gt;,bmvm3&lt;[3:0]&gt;,bmvm4&lt;[3:0]&gt;,sel[4:1],reset
0 0 0 0 0 0 0 0 0000 0 ; reset
</span><span class="si">{</span><span class="nf">_hex</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span><span class="si">}</span><span class="s"> 0 0 0 </span><span class="si">{</span><span class="nf">_hex</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span><span class="si">}</span><span class="s"> 0 0 0 1111 1 ; load
</span><span class="si">{</span><span class="nf">_hex</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span><span class="si">}</span><span class="s"> </span><span class="si">{</span><span class="nf">_hex</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span><span class="si">}</span><span class="s"> 0 0 </span><span class="si">{</span><span class="nf">_hex</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span><span class="si">}</span><span class="s"> </span><span class="si">{</span><span class="nf">_hex</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span><span class="si">}</span><span class="s"> 0 0 1111 1
</span><span class="si">{</span><span class="nf">_hex</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span><span class="si">}</span><span class="s"> </span><span class="si">{</span><span class="nf">_hex</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span><span class="si">}</span><span class="s"> </span><span class="si">{</span><span class="nf">_hex</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span><span class="si">}</span><span class="s"> 0 </span><span class="si">{</span><span class="nf">_hex</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span><span class="si">}</span><span class="s"> </span><span class="si">{</span><span class="nf">_hex</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span><span class="si">}</span><span class="s"> </span><span class="si">{</span><span class="nf">_hex</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span><span class="si">}</span><span class="s"> 0 1111 1
</span><span class="si">{</span><span class="nf">_hex</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">3</span><span class="p">])</span><span class="si">}</span><span class="s"> </span><span class="si">{</span><span class="nf">_hex</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span><span class="si">}</span><span class="s"> </span><span class="si">{</span><span class="nf">_hex</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span><span class="si">}</span><span class="s"> </span><span class="si">{</span><span class="nf">_hex</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span><span class="si">}</span><span class="s"> </span><span class="si">{</span><span class="nf">_hex</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span><span class="si">}</span><span class="s"> </span><span class="si">{</span><span class="nf">_hex</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span><span class="si">}</span><span class="s"> </span><span class="si">{</span><span class="nf">_hex</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span><span class="si">}</span><span class="s"> </span><span class="si">{</span><span class="nf">_hex</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">3</span><span class="p">])</span><span class="si">}</span><span class="s"> 0111 1; initiate display
0 </span><span class="si">{</span><span class="nf">_hex</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">3</span><span class="p">])</span><span class="si">}</span><span class="s"> </span><span class="si">{</span><span class="nf">_hex</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span><span class="si">}</span><span class="s"> </span><span class="si">{</span><span class="nf">_hex</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span><span class="si">}</span><span class="s"> 0 </span><span class="si">{</span><span class="nf">_hex</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span><span class="si">}</span><span class="s"> </span><span class="si">{</span><span class="nf">_hex</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span><span class="si">}</span><span class="s"> </span><span class="si">{</span><span class="nf">_hex</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">3</span><span class="p">])</span><span class="si">}</span><span class="s"> 1011 1; display begins
0 0 </span><span class="si">{</span><span class="nf">_hex</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">3</span><span class="p">])</span><span class="si">}</span><span class="s"> </span><span class="si">{</span><span class="nf">_hex</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span><span class="si">}</span><span class="s"> 0 0 </span><span class="si">{</span><span class="nf">_hex</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span><span class="si">}</span><span class="s"> </span><span class="si">{</span><span class="nf">_hex</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">3</span><span class="p">])</span><span class="si">}</span><span class="s"> 1101 1
0 0 0 </span><span class="si">{</span><span class="nf">_hex</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">3</span><span class="p">])</span><span class="si">}</span><span class="s"> 0 0 0 </span><span class="si">{</span><span class="nf">_hex</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">3</span><span class="p">])</span><span class="si">}</span><span class="s"> 1110 1
0 0 0 0 0 0 0 0 1111 1; last display tic
</span><span class="sh">"""</span>
</code></pre></div></div> <p>Admittedly, this is not the most elegant solution I could have come up with, but it was a very quick way to a working program. This reduces the burden of writing test cases to writing them as python lists.</p> <p>I am glad we did this, because writing multiple test cases exposed a problem with our design: when we sent signals on our \(\textbf{B}\) input lines, these signals “skipped” values when they reappeared on the registered output lines. Perhaps this is an obvious obstacle to diagnose for more experienced VLSI teams, but this was an unexpected head-scratcher for us.</p> <h2 id="resolving-mathbfb-signal-timing-violations">Resolving \(\mathbf{B}\) Signal Timing Violations</h2> <p>With some experience splitting work between us, we implemented three strategies to attempt resolving this issue</p> <ol> <li>Increasing our clock period, to see if the design passed at higher values</li> <li>Making a design variant that exposed more internal signals, to see if hold time violations were occurring on the \(\textbf{B}\) signal between processing elements.</li> <li>Adjusting longer interconnect nets (e.g., <code class="language-plaintext highlighter-rouge">clk</code>) to equalize delay between distant processing elements</li> </ol> <p>A change to the clock period in our vector files revealed that the design worked at 100 MHz (much slower than our original 500 MHz target). So, while one engineer worked on trying to cut this corner closer (a slow process; each simulation takes 30 minutes), two worked on the other two strategies.</p> <p>Our testbenches for all designs discussed thus far consist of connecting schematic I/O pins to the associated component I/O pins. If we wanted to be thorough, we would include inverters on these lines to <a href="https://www.chinachipsun.com/load-capacitance/">“load” them with capacitance</a>, but we omitted doing this in later designs to speed up our development cycles. Adjusting these testbenches to expose internal pins was not a trivial task (the only way we found to do this was to re-implement the entire component with these extra pins), and our simulations were already running into disk quota limits without these extra signals to capture. Hence, this strategy did not bear any fruit.</p> <p>It was when we turned to our clock nets when we found a solution that worked for us: our initial design of the matrix multiplier routed the clock net on a wire between the second and third row of processing elements, placing the pin on the left edge. Moving this pin to the center of this wire resolved our timing violations for all test cases we simulated at the original frequency.</p> <p>What this means for our design: if larger designs use the matrix multiplier, they must route their clock wire such that it connects with this clock net at the indicated position in the middle of the design, instead of following our prior strategy of “reusing nets wherever possible”. Now our design roughly approximates a <a href="https://vlsiweb.com/clock-tree-structures/">clock h-tree</a> and is thus able to control for clock skew by providing similar interconnect lengths between extant paths.</p> <p>Given more time, careful investigations into how much timing margin our design affords could be warranted. However, time was a resource on which we were short. Instead, we took our design to the course project demo day, knowing it would pass the cases we were assigned to test.</p> <h2 id="our-results">Our results</h2> <p><strong>Power</strong>: Our design consumes ~1.078 mW to produce a matrix multiplication</p> <p><strong>Area</strong>: The longest dimension of our design was the width at 118.51 microns</p> <p><strong>Delay</strong>: Our clock period is 2 ns</p> <p>This produces a PAD metric of 30278.5 \(\text{mW} \: \text{um}^2 \: \text{ns}\).</p> <p>Informal comparisons with other teams in the course (namely, our friends who were mutually curious) revealed this to be a fair result. Notably, our design was larger than some of our competitors but ran at a more aggressive frequency, producing a comparable PAD. We were, of course, severely outperformed by teams employing more experienced VLSI layout engineers reaching for their own graduate degrees, but this was an extremely informative, engaging, and (dare I say) fun experience that I seek to build on in future courses, positions, and blog posts.</p> <h1 id="takeaways">Takeaways</h1> <p>Having gone through the project, these are our lessons learned:</p> <ol> <li><strong>Forecasting task timeframes</strong>: Division of work depends on the work partitions being relatively equal. Since we did not consult anyone on this subject before dividing our work, our divisions ended up unequal at first. Taking time to plan this out (as well as find second opinions from subject matter experts – i.e., our T.A.s) would have ameliorated this issue.</li> <li><strong>Automation and peer development sessions</strong>: Different members of our team had learnt different tricks and developed different tools to do things. Sharing knowledge within teams is key to speeding up total development, particularly where everyone has to do a little bit of everything.</li> <li><strong>Source control</strong>: As we had all done our labs/prior work separately, if we had to do this project I would allocate more time to project setup. We had difficulty sharing our work with each other that could have been reduced with version control (such as <code class="language-plaintext highlighter-rouge">git</code>, perhaps) and decisions on project setup. (We all contributed our work on different projects, so the hierarchy we produced required several libraries of standard cells.) One “project” library and as few “dependency” libraries as possible would have served us best.</li> <li><strong>Work reviews</strong>: When we complete major milestones it pays off to do quick reviews to uncover errors and issues before downstream tasks obfuscate them. Our processing element is a key example of this: the initial layout routed the \(\textbf{B}\) pins in the wrong direction, which would have only been an obvious issue when designing vector/matrix multipliers. Resolving it before moving to these designs meant minimal rework. A better strategy would have been to decide/verify layout pin positions together before laying out the incorrect placements.</li> <li><strong>Early and repeated functional verification</strong>: Simulations on schematic netlists don’t give the parasitics and accuracy that doing it post-layout would produce, but it can still expose issues that would require layout rework if the simulations weren’t run first. The workflow should look like this: draw the schematic, then verify. Then, draw the layout and verify. Teams can multitask by ‘speculatively’ drawing the layout while simulations finish (something we did with our matrix multiplier) if they acknowledge the probability/risk of discarded work (and they have nothing else to do).</li> <li><strong>Foresight</strong>: The efforts we took to make our future work easier single-handedly made the difference between us making and missing our deadline. Provided these tangents are short, teams should look to implement workflow improvements early to gain the most benefit.</li> <li><strong>Using DRC and LVS checkers</strong>: This was a story we all had in common. At first, we would run DRC on designs to correct wire/component placement errors, only to learnt that our layout was wrong in LVS. Then, correcting the LVS errors would break DRC. Our project taught us that LVS should be prioritized first. (I also used DRC to check incremental design decisions, such as “can I place this component here, or is it too close?”)</li> </ol> <p>To reiterate, none of us carry much experience in this field. However, these tips may help other novices and engineers needing refreshers. These are all lessons I look forward to using in future work.</p>]]></content><author><name></name></author><category term="engineering"/><category term="vlsi"/><category term="code"/><category term="projects"/><category term="usc"/><category term="engineering"/><category term="vlsi"/><category term="code"/><category term="projects"/><summary type="html"><![CDATA[A writeup about a course project (EE 477 @ USC, Fall 2024) about Systolic Array Matrix Multiplication]]></summary></entry><entry><title type="html">Hello, World</title><link href="https://fsharp4.github.io/blog/2024/hello-world/" rel="alternate" type="text/html" title="Hello, World"/><published>2024-10-19T08:00:00+00:00</published><updated>2024-10-19T08:00:00+00:00</updated><id>https://fsharp4.github.io/blog/2024/hello-world</id><content type="html" xml:base="https://fsharp4.github.io/blog/2024/hello-world/"><![CDATA[<p>I just stood this website up, so I don’t have enough leftover energy to produce meaningful content here. In the meantime:</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Message</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span> <span class="n">args</span><span class="o">[])</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Drink water!"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="sample-posts"/><category term="minecraft"/><summary type="html"><![CDATA[Placeholder Post]]></summary></entry></feed>